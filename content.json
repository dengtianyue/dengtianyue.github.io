[{"title":"多对多关系的处理办法","date":"2017-03-31T11:36:05.000Z","path":"2017/03/31/多对多关系的处理办法/","text":"多对多关系的处理在数据库设计的过程中,经常会遇到两张表是多对多的关系.如订单和商品之间的关系:一个订单包含了很多商品,而一种商品同时也可能属于多个订单.这时就需要通过建立一个第三方关联表,将多对多关系拆分成两个一对多关系.其中关联表为多方. 实例如下:背景 一种菜品属于一个菜系,一个菜系也包括很多菜品; 一种菜品根据原材料分可以分为多个种类,如番茄炒蛋可以归为蛋类也可归为蔬菜类,而每个种类下也有多个菜品 通过建立菜系-菜品关联表,种类-菜品关联表来处理菜品与菜系,菜品与种类之间的多对多关系 数据表名词解释: food:菜品 foodstyle:菜系 foodtype:种类 stylelink:菜系-菜品关联表 typelink:种类-菜品关联表 对应的ER图如下:","tags":[]},{"title":"Hibernate中配置映射关系","date":"2017-03-31T11:06:43.000Z","path":"2017/03/31/Hibernate中配置映射关系/","text":"Hibernate中配置映射关系准备工作 进行Hibernate的基本配置 创建HibernateUtil工具类 进行数据表的建立 创建持久化类和映射关系文件 配置单向一对多关系使用标签在一方的hbm.xml文件中,配置单向的一对多映射,如:123456789&lt;!-- 配置单向的一对多映射 设置inverse属性为true 由多方维护关联关系 , 设置cascade=\"save-update\",当进行保存和更新时级联操作所关联的对象--&gt; &lt;set name=\"students\" table=\"student\" inverse=\"false\" lazy=\"true\" cascade=\"save-update\"&gt; &lt;!-- 指定关联的外键列 --&gt; &lt;key&gt; &lt;column name=\"gid\" /&gt; &lt;/key&gt; &lt;one-to-many class=\"entity.Student\" /&gt; &lt;/set&gt; 测试类:1234567891011121314151617181920212223242526272829//将学生添加到班级public static void add()&#123; Grade g = new Grade(\"JAVA1\",\"JAVA软件开发一班\"); Student stu1 = new Student(\"张三\",\"男\"); Student stu2 = new Student(\"青青\",\"男\"); //如果希望在学生表中添加对应的班级编号,需要在班级中添加学生,建立关联关系 g.getStudents().add(stu1); g.getStudents().add(stu2); Session session = HibernateUtil.getSession(); Transaction tx = session.beginTransaction(); session.save(g); session.save(stu1); session.save(stu2); tx.commit(); HibernateUtil.closeSession(session);&#125;//查询班级学生信息public static void findStudentsByGrade()&#123; Session session = HibernateUtil.getSession(); Grade grade = (Grade) session.get(Grade.class, 1); System.out.println(grade.getGname()+\",\"+grade.getGdesc()); Set&lt;Student&gt;students = grade.getStudents(); for(Student stu : students)&#123; System.out.println(stu.getSname()+\",\"+stu.getSex()); &#125;&#125; 单向多对一的配置在多方的hbm.xml文件中,使用标签配置如:12&lt;!-- 配置多对一关联配置 --&gt; &lt;many-to-one name=\"grade\" class = \"entity.Grade\" column=\"gid\"&gt;&lt;/many-to-one&gt; 当双方关系都配置好后,即双向映射已经配置测试:1234567891011121314151617181920212223242526272829303132//保存,测试多对一映射public static void save()&#123; Grade g = new Grade(\"JAVA1\",\"JAVA软件开发一班\"); Student stu1 = new Student(\"呵呵\",\"男\"); Student stu2 = new Student(\"小美\",\"女\"); //设置关联关系 g.getStudents().add(stu1); g.getStudents().add(stu2); stu1.setGrade(g); stu2.setGrade(g); Session session = HibernateUtil.getSession(); Transaction tx = session.beginTransaction(); session.save(g); //session.save(stu1); //session.save(stu2); tx.commit(); HibernateUtil.closeSession(session);&#125; //双向多对一测试public static void findGradeByStudent()&#123; Session session = HibernateUtil.getSession(); Student stu = (Student) session.get(Student.class, 2); Grade grade = stu.getGrade(); System.out.println(stu.getSid()+\",\"+stu.getSname()+\",\"+stu.getSex()); System.out.println(grade.getGid()+\",\"+grade.getGname()+\",\"+grade.getGdesc()); HibernateUtil.closeSession(session);&#125; 相关知识点:1.inverse属性的用法在一对多关联关系中默认有one方维护关联关系，因为是双向一对多关联关系，所以one方需进行两次关联关系的维护，当在one方设置inverse属性值为true时，反转，即让多方进行关联关系的维护，此时不需要执行update 多方表名（student） set 单方表的主键（多方表中的外键即gid）等于单方某记录的gid值当sid为值一，sid为值二，，，，（student表中有n个记录则需执行n次操作）这些操作，所以当在one方设置inverse属性值为true时有利于改善系统性能。 2.cascade属性的用法 当设置cascade属性部位none时,Hibernate会自动持久化所关联的对象 cascade属性的常用设置: all—&gt;对所有操作进行级联操作 save-update–&gt;执行保存和更新操作时进行级联操作 delete–&gt;执行删除操作时进行级联操作 none–&gt;对所有操作不进行级联操作","tags":[]},{"title":"Hibernate的基本用法","date":"2017-03-29T16:28:42.000Z","path":"2017/03/30/Hibernate的基本用法/","text":"Hibernate 的基本开发步骤1.编写配置文档hibernat.cfg.xml例如:1234567891011121314151617181920&lt;session-factory&gt; &lt;!--数据库用户名--&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;!--数据库登录密码--&gt; &lt;property name=\"connection.password\"&gt;123456&lt;/property&gt; &lt;!--jdbc驱动 --&gt; &lt;property name=\"connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--设置端口 字符集等 --&gt; &lt;property name=\"connection.url\"&gt;jdbc:mysql://127.0.0.1:3306/hibernate?useUnicode=true&amp;characterEncoding=utf-8&lt;/property&gt; &lt;!--方言 --&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!--是否直接打印出sql语句 --&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!--sql格式 --&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;!--ddl生成策略--&gt; &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!--对应的映射 --&gt; &lt;mapping resource=\"Students.hbm.xml\"/&gt; &lt;/session-factory&gt; 单一主键:1.assigned 由java应用程序负责生成（手工赋值） 2.native 由底层数据库自动生成标示符，如果是MySQL就是increment，如果是Oracle就是sequence，等等 Ps1：assigned注意：如果实体类中设置的主键id是基本类型int的话，则可以不用赋值，系统默认值为0；如是引用类型Integer话，则默认值为null，不赋值系统则报错。 Ps2：native注意：系统会自动选择该数据库对应的自动增值方式，从1开始。即使手动给他赋值，也不会起作用，但也不会报错。 2.编写实体类需要符合JAVA BEAN 规范 即:1、公有的类。2、提供公有的不带参数的默认的构造方法。3、属性私有。4、属性setter/getter封装 3.生成对应实体类的映射文件可在包上鼠标右键,点击new-&gt;other-&gt;Hibernate-&gt;Hibernate XML Mapping file(hbm.xml)自动创建如:1234567891011121314151617181920212223242526&lt;hibernate-mapping&gt; &lt;class name=\"Students\" table=\"STUDENTS\"&gt; &lt;id name=\"id\" type=\"int\"&gt; &lt;column name=\"ID\" /&gt; &lt;!--主键策略--&gt; &lt;generator class=\"assigned\" /&gt; &lt;/id&gt; &lt;property name=\"sname\" type=\"java.lang.String\"&gt; &lt;column name=\"SNAME\" /&gt; &lt;/property&gt; ...................... &lt;!-- &lt;property name=\"address\" type=\"java.lang.String\"&gt; &lt;column name=\"ADDRESS\" /&gt; &lt;/property&gt; --&gt; &lt;property name=\"picture\" type=\"java.sql.Blob\"&gt; &lt;column name=\"PICTURE\" /&gt; &lt;/property&gt; &lt;component name=\"address\" class=\"Address\"&gt; &lt;property name=\"postcode\" column=\"POSTCODE\"/&gt; &lt;property name=\"phone\" column=\"PHONE\"/&gt; &lt;property name=\"address\" column=\"ADDRESS\"/&gt; &lt;/component&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 常用配置如下:4.调用Hibernate API进行测试例如:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.sql.Blob;import java.util.Date;import org.hibernate.Hibernate;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;import org.hibernate.service.ServiceRegistryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;//测试类public class StudentsTest &#123; private SessionFactory sessionFactory; private Session session; private Transaction transaction; @Before public void init()&#123; //创建配置对象 Configuration config = new Configuration().configure(); //创建服务注册对象 ServiceRegistry serviceRegistry = new ServiceRegistryBuilder().applySettings(config.getProperties()).buildServiceRegistry(); //创建会话工厂对象 sessionFactory = config.buildSessionFactory(serviceRegistry); //会话对象 session = sessionFactory.openSession(); //开启事务 transaction = session.beginTransaction(); &#125; @After public void distory()&#123; //提交事务 transaction.commit(); session.close(); sessionFactory.close(); &#125; @Test public void testSaveStudents()&#123; //生成学生对象 Students s = new Students(1,\"小明\",\"男\",new Date()); Address address = new Address(\"312312\",\"09876666\",\"杭州\"); s.setAddress(address); session.save(s);//保存对象进入数据库 &#125; @Test public void testWriteBlob()throws Exception&#123; Students s = new Students(4,\"小明\",\"男\",new Date()); //获得照片文件 File f = new File(\"f:\"+File.separator+\"头像.jpg\"); //获得输入流 InputStream input = new FileInputStream(f); //创建一个Blob对象 Blob image = Hibernate.getLobCreator(session).createBlob(input, input.available()); //设置照片属性 s.setPicture(image); //保存学生 session.save(s); &#125; @Test public void testReadBlob()throws Exception &#123; Students s = (Students) session.get(Students.class, 4); //获得blob对象 Blob image =s.getPicture(); //创建输入流 InputStream input = image.getBinaryStream(); //创建输出流 File f = new File(\"f:\"+File.separator+\"头像2.jpg\"); OutputStream output = new FileOutputStream(f); //缓冲区 byte[] buff = new byte[input.available()]; input.read(buff); output.write(buff); input.close(); output.close(); &#125; Hibernate其他一些基础知识transaction：事务Hibernate对数据的操作都是封装在事务当中，并且默认是非自动提交的方式。所以用session保存对象时，如果不开启事务，并且手工提交事务，对象并不会真正保存在数据库中 如上例中的： 1234 //开启事务transaction = session.beginTransaction(); //提交事务transaction.commit(); session1.getCurrentSession在事务提交或者回滚之后会自动关闭，而openSesssion需要你手动关闭。如果使用openSession而没有手动关闭，多次之后会导致连接池溢出！2.openSession每次创建新的session对象，getCurrentSession使用现有的session对象（现有session没commit之前） 基本类型 对象类型","tags":[]},{"title":"Hello World","date":"2017-03-29T03:19:08.088Z","path":"2017/03/29/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]