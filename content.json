[{"title":"Mybatis入门总结","date":"2017-08-03T02:04:50.000Z","path":"2017/08/03/Mybatis入门总结/","text":"[TOC] #(一)Mybaits入门基础UTF-8” ?&gt;&lt;!DOCTYPE configurationPUBLIC “-//mybatis.org//DTD Config 3.0//EN”“http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;!– 使用jdbc事务管理,事务控制由mybatis管理– Mybatis入门小程序需求：(1).根据用户id（主键）查询用户信息 (2).根据用户名称模糊查询用户信息(3).添加用户 4).删除用户(5).更新用户 ###1.SqlMapConfig.xml的配置文件内容12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据库连接池,由mybatis管理--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"sqlmap/User.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; ###2.实体User.java内容1234567891011121314//import省略public class User &#123; // 属性名称和数据库字段名称保持一致 private Integer id; // 姓名 private String username; // 性别 private String sex; // 地址 private String address; // 生日 private Date birthday; //get/set方法省略&#125; ###3.映射文件User.xml的内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace命名空间,作用就是对sql进行分类化的管理,理解为sql隔离 注意:使用mapper代理开发时，namespace有特殊作用 --&gt;&lt;mapper namespace=\"test\"&gt;&lt;!-- 在映射文件中配置很多sql语句 --&gt;&lt;!-- 需求：通过Id查询用户表的记录 --&gt;&lt;!-- 通过SELECT执行数据库查询 id:标识映射文件中的sql，称为statement的id; 将sql语句封装在mapperStatement的对象中，所以Id称为Statement的id; parameterType:指定输入参数的类型,这里指定int型 #&#123;&#125;:表示一个占位符; #&#123;id&#125;:其中Id表示接收输入的参数，参数名称就是Id,如果输入参数是简单类型，#&#123;&#125;中的参数名可以任意，可以是value或者其它名称; resultType:指定sql输出结果所映射的java对象类型,select指定resultType表示将单条记录映射成java对象。--&gt;&lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"com.mybatis.entity.User\" &gt; select * from t_user where id=#&#123;id&#125;&lt;/select&gt;&lt;!-- 根据用户名称模糊查询用户信息,可能返回多条数据 resultType:指定的就是单条记录所映射的java类型; $&#123;&#125;:表示拼接sql字符串，将接收到的参数内容不加任何修饰拼接在sql中. 使用$&#123;&#125;拼接sql，可能会引起sql注入 $&#123;value&#125;:接收输入参数的内容，如果传入的是简单类型,$&#123;&#125;中只能使用value --&gt;&lt;select id=\"findUserByName\" parameterType=\"java.lang.String\" resultType=\"com.mybatis.entity.User\" &gt; select * from t_user where username LIKE '%$&#123;value&#125;%'&lt;/select&gt;&lt;!-- 添加用户parameterType:指定输入的参数类型是pojo(包括用户信息);#&#123;&#125;中指定pojo的属性名称，接收到pojo对象的属性值 ,mybatis通过OGNL(类似struts2的OGNL)获取对象的属性值--&gt;&lt;insert id=\"insertUser\" parameterType=\"com.mybatis.entity.User\" &gt; &lt;!-- 将insert插入的数据的主键返回到User对象中; select last_insert_id():得到刚insert进去记录的主键值，只适用于自增主键; keyProperty:将查询到的主键值，设置到parameterType指定的对象的那个属性 order:select last_insert_id()执行顺序，相对于insert语句来说它的执行顺序。 resultType:指定select last_insert_id()的结果类型; --&gt; &lt;selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\"&gt; select last_insert_id() &lt;/selectKey&gt; &lt;!-- 使用mysql的uuid()，实现非自增主键的返回。 执行过程:通过uuid()得到主键，将主键设置到user对象的Id的属性中，其次，在insert执行时，从user对象中取出Id属性值; &lt;selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"java.lang.String\"&gt; select uuid() &lt;/selectKey&gt; insert into t_user (id,username,birthday,sex,address) values(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) --&gt; insert into t_user (username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt;&lt;!-- 删除用户 根据ID删除用户,需要输入Id值--&gt; &lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\"&gt; delete from t_user where id=#&#123;id&#125; &lt;/delete&gt;&lt;!-- 更新用户 需要传入用户的Id和用户的更新信息 parameterType:指定User对象，包括Id和用户的更新信息,注意：Id是必须存在的 #&#123;id&#125;:从输入的User对象中获取Id的属性值--&gt;&lt;update id=\"updateUser\" parameterType=\"com.mybatis.entity.User\"&gt; update t_user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&lt;/update&gt;&lt;/mapper&gt; ###4.测试程序12345678910111213141516171819202122232425262728293031323334353637383940414243//import省略public class MybatisService &#123; // 根据Id查询用户信息，得到一条记录结果 @Test public void findUserByIdTest() &#123; // mybatis的配置文件 String resource = \"SqlMapConfig.xml\"; InputStream inputStream = null; SqlSession sqlSession = null; try &#123; inputStream = Resources.getResourceAsStream(resource); // 1.创建会话工场,传入mybatis的配置文件信息 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); // 2.通过工厂得到SqlSession sqlSession = sqlSessionFactory.openSession(); // 3.通过sqlSession操作数据库 // 第一个参数：映射文件中的statement的Id,等于namespace + \".\" + statement的id; // 第二个参数:指定和映射文件中所匹配的parameterType类型的参数; // sqlSession.selectOne结果是与映射文件所匹配的resultType类型的对象; // selectOne：查询一条结果 User user = sqlSession.selectOne(\"test.findUserById\", 1); System.out.println(user.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //其他省略 ###5.数据库sql脚本12345678910111213CREATE TABLE t_user ( id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, username VARCHAR(30) NOT NULL COMMENT '用户名称', birthday DATE DEFAULT NULL COMMENT '生日', sex CHAR(2) DEFAULT NULL COMMENT '性别', address VARCHAR(256) DEFAULT NULL COMMENT '地址');INSERT INTO t_user (username,birthday,sex,address) VALUES ('小A','2015-06-27','2','北京'), ('小B','2015-06-27','2','北京'), ('小C','2015-06-27','1','北京'), ('小D','2015-06-27','2','北京'); #(二)替代原始DAO开发的mapper开发原始dao接口中存在大量模版方法,可以通过实现mapper接口减少工作量 ##mapper代理方法(只需要mapper接口，相当于dao接口) ###1.概要： (1).编写XXXmapper.xml的映射文件 (2).编写mapper接口需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。 ###2.开发规范： (1).在XXXmapper.xml中namespace等于mapper接口地址；1&lt;mapper namespace=\"com.mybatis.mapper.UserMapper\"&gt; (2).XXXmapper.java接口中的方法和mapper.xml中的statement的Id一致。 (3).mapper.java接口中的方法输入参数和mapper.xml中statement的parameterType指定的类型一致。 (4).mapper.java接口中的方法的返回值类型和mapper.xml中statement的resultType指定的类型一致。123&lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"com.mybatis.entity.User\" &gt; select * from t_user where id=#&#123;id&#125;&lt;/select&gt; 123public interface UserMapper &#123; /** 根据ID查询用户信息 */ public User findUserById(int id); 小结：以上的开发规范主要是对下面的代码进行统一生成 ###3.UserMapper.java类代码(等同于DAO接口类代码)1234567891011121314151617public interface UserMapper &#123; /** 根据ID查询用户信息 */ public User findUserById(int id); /** 根据用户名称模糊查询用户信息 */ public List&lt;User&gt; findUserByName(String username); /** 添加用户 */ public void insertUser(User user); /** 根据ID删除用户 */ public void deleteUser(Integer id); /** 根据ID更新用户 */ public void updateUser(User user);&#125; ###4.将原来的User.xml拷贝修改名称为UserMapper.xml,只需命名空间为对应接口类1234&lt;!-- namespace命名空间,作用就是对sql进行分类化的管理,理解为sql隔离 注意:使用mapper代理开发时，namespace有特殊作用,namespace等于mapper接口地址 --&gt;&lt;mapper namespace=\"com.mybatis.mapper.UserMapper\"&gt; ###5.在SqlMapConfig.xml中加载UserMapper.xml12345&lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"sqlmap/User.xml\"/&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt; ###6.Junit测试UserMapperTest.java123456789101112131415161718192021222324252627public class UserMapperTest &#123; private SqlSessionFactory sqlSessionFactory; // 此方法是在执行findUserByIdTest之前执行 @Before public void setUp() throws Exception &#123; String resource = \"SqlMapConfig.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); // 创建SqlSessionFcatory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void testInsertUser() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); // 创建Usermapper对象，mybatis自动生成mapper代理对象 User user = new User(); user.setUsername(\"者别\"); user.setSex(\"1\"); user.setAddress(\"蒙古乞颜部落\"); user.setBirthday(new Date()); UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.insertUser(user); sqlSession.commit(); sqlSession.close(); &#125; //其他省略 ###注意:mapper接口只能有一个参数，可以使用包装类型的pojo满足不同的业务方法的需求。 #(三)动态SQL ##动态SQL ###1.定义 mybatis核心对sql语句进行灵活操作，通过表达式进行判断，对sql进行灵活拼接、组装。 ###2.案例需求 用户信息综合查询列表这个statement的定义使用动态sql，对查询条件进行判断，如果输入参数不为空才进行查询拼接。 ###3.UserMapper.xml 12345678910111213141516171819202122&lt;!-- 用户信息综合查询 #&#123;userCustom.sex&#125;:取出pojo包装对象中性别值 $&#123;userCustom.username&#125;：取出pojo对象中用户名称--&gt; &lt;select id=\"findUserList\" parameterType=\"com.mybatis.entity.UserQueryVo\" resultType=\"com.mybatis.entity.UserCustom\"&gt; select * from t_user &lt;!-- 动态sql查询：where可以自动去掉第一个and --&gt; &lt;where&gt; &lt;if test=\"userCustom!=null\"&gt; &lt;if test=\"userCustom.sex!=null and userCustom.sex!='' \"&gt; and sex=#&#123;userCustom.sex&#125; &lt;/if&gt; &lt;if test=\"userCustom.username!=null and userCustom.username!='' \"&gt; and username=#&#123;userCustom.username&#125; &lt;/if&gt; &lt;/if&gt; &lt;/where&gt;&lt;!-- where sex=#&#123;userCustom.sex&#125; and username LIKE '%$&#123;userCustom.username&#125;%' --&gt; &lt;/select&gt; ###4.测试代码12345678910111213141516171819@Test public void testFindUserList() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); //创造查询条件 UserQueryVo userQueryVo = new UserQueryVo(); UserCustom userCustom = new UserCustom();// userCustom.setSex(\"2\"); //这里使用动态sql，如果不设置某个值，条件不会拼接sql中 userCustom.setUsername(\"小\"); userQueryVo.setUserCustom(userCustom); // 创建Usermapper对象，mybatis自动生成mapper代理对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;UserCustom&gt;list=mapper.findUserList(userQueryVo); //测试动态sql，属性的非空判断测试// List&lt;UserCustom&gt;list=mapper.findUserList(null); System.out.println(list); sqlSession.commit(); sqlSession.close(); &#125; ##SQL片段 ###1.需求 将上边的动态sql判断代码抽取出来，组成一个sql片段，其它的statement中就可以引用sql片段，方便开发。 ###2.定义sql片段 123456789101112131415&lt;!-- 定义sql片段，Id是唯一标识 建议：是基于单表来定义sql片段，这样的话sql片段的可重用性才高，在sql片段中不要包含where --&gt; &lt;sql id=\"query_user_where\" &gt; &lt;if test=\"userCustom!=null\"&gt; &lt;if test=\"userCustom.sex!=null and userCustom.sex!='' \"&gt; and sex=#&#123;userCustom.sex&#125; &lt;/if&gt; &lt;if test=\"userCustom.username!=null and userCustom.username!='' \"&gt; and username=#&#123;userCustom.username&#125; &lt;/if&gt; &lt;/if&gt; &lt;/sql&gt; ###3.在mapper.xml中定义的statement中引用sql片段1234567891011121314&lt;!-- 用户信息综合查询 #&#123;userCustom.sex&#125;:取出pojo包装对象中性别值 $&#123;userCustom.username&#125;：取出pojo对象中用户名称--&gt; &lt;select id=\"findUserList\" parameterType=\"com.mybatis.entity.UserQueryVo\" resultType=\"com.mybatis.entity.UserCustom\"&gt; select * from t_user &lt;!-- 动态sql查询：where可以自动去掉第一个and --&gt; &lt;where&gt; &lt;!-- 引用sql片段的id，如果refid指定的不在本mapper.xml中，需要前边加namespace --&gt; &lt;include refid=\"query_user_where\"&gt;&lt;/include&gt; &lt;!-- 这里可以引用其它的sql片段 --&gt; &lt;/where&gt; &lt;/select&gt; ##foreach作用：向sql传递数组或者list，mybatis使用foreach解析12345678910111213141516171819202122232425262728293031323334353637383940414243##foreach作用：向sql传递数组或者list，mybatis使用foreach解析在用户查询列表和查询总数的statement中增加多个id输入查询。###1.需求 sql语句如下： 两种方法： SELECT * FROM t_user WHERE id=1 OR id=10 OR id=16 SELECT * FROM t_user WHERE id IN(1,10,16)###2.在输入参数包装类型中添加List&lt;Integer&gt; ids 传入多个id```JAVApackage com.mybatis.entity;import java.util.List;/** * * @ClassName: UserQueryVo * @Description: TODO(包装类型) * @author warcaft * */public class UserQueryVo &#123; public List&lt;Integer&gt; ids; public List&lt;Integer&gt; getIds() &#123; return ids; &#125; public void setIds(List&lt;Integer&gt; ids) &#123; this.ids = ids; &#125;&#125; ###3.mapper.xml代码123456789101112131415161718192021&lt;!-- 实现下边的sql拼接 select * from t_user where id=1 OR id=2 OR id=3 --&gt; &lt;select id=\"findUserByIds\" parameterType=\"com.mybatis.entity.UserQueryVo\" resultType=\"com.mybatis.entity.User\"&gt; select * from t_user &lt;where&gt; &lt;if test=\"ids!=null\"&gt; &lt;!-- 使用foreach遍历ids collection:指定输入对象的集合属性 item:每个遍历生成对象中 open：开始遍历时拼接的串 close:技术遍历时拼接的串 separator:遍历的两个对象中需要拼接的串 --&gt; &lt;foreach collection=\"ids\" item=\"user_id\" open=\"AND (\" close=\")\" separator=\"or\"&gt; id=#&#123;user_id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 12345678910111213141516171819202122###4.select * from t_user where id in(1,2,3)的mapper.xml配置```XML&lt;select id=&quot;findUserByIds&quot; parameterType=&quot;com.mybatis.entity.UserQueryVo&quot; resultType=&quot;com.mybatis.entity.User&quot;&gt; select * from t_user &lt;where&gt; &lt;if test=&quot;ids!=null&quot;&gt; &lt;!-- 使用foreach遍历ids collection:指定输入对象的集合属性 item:每个遍历生成对象中 open：开始遍历时拼接的串 close:技术遍历时拼接的串 separator:遍历的两个对象中需要拼接的串 --&gt; &lt;!-- 实现“ select * from t_user where id in(1,2,3)”拼接 --&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;user_id&quot; open=&quot;AND id in (&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; id=#&#123;user_id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; ###5.userMapper.java1234 1public interface UserMapper &#123; //ids查询用户数据 public List&lt;User&gt; findUserByIds(UserQueryVo userQueryVo);&#125; ###6.Junit测试代码123456789101112131415161718public void findUserByIdsTest() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); // 创建Usermapper对象，mybatis自动生成mapper代理对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); //创造查询条件 UserQueryVo userQueryVo = new UserQueryVo(); //传入多个id List&lt;Integer&gt; ids=new ArrayList&lt;Integer&gt;(); ids.add(1); ids.add(2); ids.add(3); //将ids通过userQueryVo传入statement中 userQueryVo.setIds(ids); //调用userMapper的代码 List&lt;UserCustom&gt; userList= mapper.findUserList(userQueryVo); System.out.println(userList); sqlSession.close();&#125;","tags":[]},{"title":"SpringMVC基于注解的HelloWord","date":"2017-08-03T02:04:25.000Z","path":"2017/08/03/SpringMVC基于注解的HelloWord/","text":"#1.前端控制器配置在我们的web.xml中添加如下配置：12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt; &lt;display-name&gt;springMVCDemo&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt; load-on-startup：表示启动容器时初始化该Servlet；url-pattern：表示哪些请求交给Spring Web MVC处理， “/” 是用来定义默认servlet映射的。也可以如“*.html”表示拦截所有以html为扩展名的请求。自此请求已交给Spring Web MVC框架处理，因此我们需要配置Spring的配置文件，默认DispatcherServlet会加载WEB-INF/[DispatcherServlet的Servlet名字]-servlet.xml配置文件。本示例为WEB-INF/springMVC-servlet.xml。 #2.控制器实现现在的处理器无需实现/继承任何接口/类，只需要在相应的类/方法上放置相应的注解说明下即可，非常方便。可以通过在一个POJO类上放置@Controller或@RequestMapping，即可把一个POJO类变身为处理器；@RequestMapping(value = “/hello”) 请求URL(/hello) 到 处理器的功能处理方法的映射；模型数据和逻辑视图名的返回。1234567891011121314151617package controller;@Controller // 或 @RequestMapping //①将一个POJO类声明为处理器public class HelloWorldController &#123; @RequestMapping(value = \"/hello\") //②请求URL到处理器功能处理方法的映射 public ModelAndView helloWorld() &#123; //1、收集参数 //2、绑定参数到命令对象 //3、调用业务对象 //4、选择下一个页面 ModelAndView mv = new ModelAndView(); //添加模型数据 可以是任意的POJO对象 mv.addObject(\"message\", \"Hello World!\"); //设置逻辑视图名，视图解析器会根据该名字解析到具体的视图页面 mv.setViewName(\"hello\"); //将被视图解析器解析为 hello.jsp return mv; //○3 模型数据和逻辑视图名 &#125;&#125; #3.Spring配置文件chapter6-servlet.xml ##3.1、HandlerMapping和HandlerAdapter的配置Spring3.1开始的版本，建议使用RequestMappingHandlerMapping和RequestMappingHandlerAdapter。 ##3.2、视图解析器的配置还是使用之前的org.springframework.web.servlet.view.InternalResourceViewResolver。 ##3.3、处理器的配置只需要将处理器实现类注册到spring配置文件即可，spring的DefaultAnnotationHandlerMapping或RequestMappingHandlerMapping能根据注解@Controller或@RequestMapping自动发现。123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;!--Spring3.1开始的注解 HandlerMapping --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\" /&gt; &lt;!--Spring3.1开始的注解 HandlerAdapter --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\" /&gt; &lt;!-- 添加viewResolver --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" /&gt; &lt;!-- 前缀和后缀 --&gt; &lt;property name=\"prefix\" value=\"/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 处理器 --&gt; &lt;bean class=\"controller.HelloWorldController\" /&gt;&lt;/beans&gt; #4.视图页面（/WEB-INF/hello.jsp1234567891011&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;message&#125;&lt;/body&gt;&lt;/html&gt; ${message}：表示显示由HelloWorldController处理器传过来的模型数据。 ##常用映射方法 ##1.普通URL路径映射@RequestMapping(value={“/test1”, “/user/create”})：多个URL路径可以映射到同一个处理器的功能处理方法。 ##2.URI模板模式映射@RequestMapping(value=”/users/{userId}”)：{×××}占位符， 请求的URL可以是 “/users/123456”或“/users/abcd”，通过6.6.5讲的通过@PathVariable可以提取URI模板模式中的{×××}中的×××变量。@RequestMapping(value=”/users/{userId}/create”)：这样也是可以的，请求的URL可以是“/users/123/create”。@RequestMapping(value=”/users/{userId}/topics/{topicId}”)：这样也是可以的，请求的URL可以是“/users/123/topics/123”。 ##3.Ant风格的URL路径映射@RequestMapping(value=”/users/“)：可以匹配“/users/abc/abc”，但“/users/123”将会被【URI模板模式映射中的“/users/{userId}”模式优先映射到】。@RequestMapping(value=”/product?”)：可匹配“/product1”或“/producta”，但不匹配“/product”或“/productaa”;@RequestMapping(value=”/product“)：可匹配“/productabc”或“/product”，但不匹配“/productabc/abc”;@RequestMapping(value=”/product/“)：可匹配“/product/abc”，但不匹配“/productabc”;@RequestMapping(value=”/products//{productId}”)：可匹配“/products/abc/abc/123”或“/products/123”，也就是Ant风格和URI模板变量风格可混用;","tags":[]},{"title":"Struts-通配符","date":"2017-07-18T08:11:37.000Z","path":"2017/07/18/Struts-通配符/","text":"Struts2使用通配符配置可以减少action的配置例如:123456789101112&lt;package name=\"foods\" namespace=\"/foods\" extends=\"struts-default\"&gt; &lt;action name=\"*_*\" class=\"action.&#123;1&#125;Action\" method = \"&#123;2&#125;\"&gt; &lt;result name=\"queryWhatoeat_success\"&gt;/foods/queryWhatoeat_success.jsp&lt;/result&gt; &lt;result name=\"queryWhatoeat2_success\"&gt;/foods/queryWhatoeat_success2.jsp&lt;/result&gt; &lt;result name=\"queryLikeFoods_success\"&gt;/foods/queryLikeFoods_success.jsp&lt;/result&gt; &lt;result name=\"queryDislikeFoods_success\"&gt;/foods/queryDislikeFoods_success.jsp&lt;/result&gt; &lt;result name=\"addLikeFoods_success\" &gt;/foods/queryWhatoeat_success.jsp&lt;/result&gt; &lt;result name=\"addDislikeFoods_success\" &gt;/foods/queryWhatoeat_success.jsp&lt;/result&gt; &lt;result name=\"deleteLikeFoods_success\" &gt;/foods/queryWhatoeat_success.jsp&lt;/result&gt; &lt;result name=\"deleteDislikeFoods_success\" &gt;/foods/queryWhatoeat_success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 在jsp中其对应的映射为:1&lt;a href=\"&lt;%=path%&gt;/foods/Foods_addLikeFoods.action&gt;喜欢&lt;/a&gt; 在此链接中 /foods 对应 xml中的 namespaceFoods_addLikeFoods.action 中Foods 对应xml中的第一个,作用于 class=”action.{1}Action 中的{1}位置addLikeFoods 对应第二个,作用于 method = “{2}” 中的{2}位置 则此例相当于配置action:123&lt;package name=\"foods\" namespace=\"/foods\" extends=\"struts-default\"&gt; &lt;action name=\"Foods_addLikeFoods\" class=\"action.FoodsAction\" method = \"addLikeFoods\"&gt;&lt;/action&gt;&lt;/package&gt;","tags":[]},{"title":"Struts入门及使用gson将数据转为json格式","date":"2017-07-18T07:57:17.000Z","path":"2017/07/18/Struts入门及使用gson将数据转为json格式/","text":"Gson 是 Google 提供的用来在 Java 对象和 JSON 数据之间进行映射的 Java 类库。可以将一个 JSON 字符串转成一个 Java 对象，或者反过来将JSON格式解析 Gson的基本用法Gson提供了fromJson() 和toJson() 两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HelloWorldAction extends SuperAction &#123; /** * */ private static final long serialVersionUID = 1L; @Override public String execute()&#123; //创建Gson对象 Gson gson = new Gson(); //将对象类型转为jsonObject,并传入session中 System.out.println(\"===============jsonObject===================\"); Student student = new Student(); student.setAge(12); student.setGender(\"男\"); student.setId(\"2333333\"); student.setName(\"orz\"); student.setEmailAddress(\"123123@2333.com\"); String jsonObject = gson.toJson(student); session.setAttribute(\"jsonObject\", jsonObject); //将list转为json格式,并传入session中 System.out.println(\"===============jsonList===================\"); Student student2 = new Student(); student2.setAge(14); student2.setGender(\"男\"); student2.setId(\"2332312312312333\"); student2.setName(\"o2333z\"); student2.setEmailAddress(\"66623@888.com\"); List&lt;Student&gt;students = new ArrayList&lt;Student&gt;(); students.add(student); students.add(student2); String jsonList = gson.toJson(students); session.setAttribute(\"jsonList\", jsonList); //将数组转为jsonArray并传入session中 System.out.println(\"===============jsonArray===================\"); String[] s = &#123;\"233\",\"哈哈哈\",\"31233地方\"&#125;; String jsonArray = gson.toJson(s); session.setAttribute(\"jsonArray\", jsonArray); //解析json System.out.println(\"==============解析json====================\"); Student student3 = gson.fromJson(jsonObject, Student.class); System.out.println(student3.toString()); return \"execute_success\"; &#125;&#125; jsp获得数据1234&lt;s:property value=\"#session.jsonObject\"/&gt;&lt;br&gt;&lt;s:property value=\"#session.jsonArray\"/&gt;&lt;br&gt;&lt;s:iterator value=\"#session.jsonList\" var =\"slist\"&gt;&lt;s:property value=\"#slist\"/&gt; Struts的基本用法1.配置web.xml文件12345678&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2.编写action文件,返回一个结果值A,如下列的 “execute_success”123456789101112public class HelloWorldAction extends SuperAction &#123; /** * */ @Override public String execute()&#123; return \"execute_success\"; &#125;&#125; 3.配置struts.xml文件123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.1//EN\" \"http://struts.apache.org/dtds/struts-2.1.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"helloworld\" class=\"action.HelloWorldAction\" method = \"execute\"&gt; &lt;result name=\"execute_success\"&gt;/result.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 4.在jsp文件中配置执行的动作1&lt;a href=\"helloworld\"&gt;test&lt;/a&gt;","tags":[]},{"title":"'学习Spring的第一个HelloWorld'","date":"2017-05-17T03:09:57.000Z","path":"2017/05/17/学习Spring的第一个HelloWorld/","text":"1 配置Spring新建一个java工程,导入如下包: 2 开始Spring编程1 新建一个HelloWorld.java1234567891011package test;public class HelloWorld &#123; private String info ; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125;&#125; 2 编写配置文件applicationContext.xml在当前工程下创建一个xml文件,添加如下代码123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- 配置需要被Spring管理的Bean（创建，创建后放在了Spring IOC容器里面）--&gt; &lt;bean id=\"hello\" class=\"test.HelloWorld\"&gt; &lt;!-- 配置该Bean需要注入的属性（是通过属性set方法来注入的） --&gt; &lt;property name=\"info\" value=\"Hello World!\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 3 反转控制开始在Main.java中添加如下：12345678910111213141516171819package test;import org.springframework.beans.factory.BeanFactory;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; //获取Spring的ApplicationContext配置文件，注入IOC容器中 //(Map: key:String, bean标签的id属性值 ==&gt;value:Object, bean标签class属性所指类的实例) BeanFactory factory = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); /* HelloWorld hw1 = new HelloWorld(); hw1.setInfo(\"Hello World!\"); */ //Spring相当于如上代码,通过getBean获取xml文件中对应id值的Bean,在xml文件中配置该Bean需要注入的属性 //不需要自己new对象以及赋值. HelloWorld hw1 = (HelloWorld)factory.getBean(\"hello\");//map.get(\"hello\") System.out.println(hw1.getInfo()); System.out.println(hw1); &#125;&#125; 3 测试结果 3 总结Spring可以通过配置的方法取得对象，而不再用new的方法来取得对象 先在xml配置文件中配置bean标签,如:1234&lt;bean id=\"hello\" class=\"test.HelloWorld\"&gt; &lt;!-- 配置该Bean需要注入的属性（是通过属性set方法来注入的） --&gt; &lt;property name=\"info\" value=\"Hello World!\"/&gt; &lt;/bean&gt; 其中id 为bean的key,通过之后getBean()取得配置的Bean.class 为创建的类所在包+类名property标签为该Bean配置注入的属性. 反转控制 1 通过1BeanFactory factory = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 来获取配置文件2 通过getBean获取xml文件中对应id值的Bean,就可以取得我们想要得到的对象了.","tags":[]},{"title":"hexo常用命令","date":"2017-05-15T15:17:09.000Z","path":"2017/05/15/hexo常用命令/","text":"简写hexo n == hexo new hexo p == hexo publish hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate –deploy hexo deploy –generatehexo deploy -g hexo server -g草稿hexo publish [layout] &lt;title&gt; 模版hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] hexo new photo “My Gallery” hexo new “Hello World” –lang tw变量 描述layout 布局title 标题date 文件建立日期title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。模版（Scaffold）hexo new photo &quot;My Gallery&quot; 变量 描述layout 布局title 标题date 文件建立日期写作hexo new page hexo new post 变量 描述:title 标题:year 建立的年份（4 位数）:month 建立的月份（2 位数）:i_month 建立的月份（去掉开头的零）:day 建立的日期（2 位数）:i_day 建立的日期（去掉开头的零）推送到服务器上hexo n #写文章 hexo g #生成 hexo d #部署 #可与 hexo g 合并为 hexo d -g 报错1.ERROR Deployer not found: gitnpm install hexo-deployer-git –save 来源： http://www.tuicool.com/articles/yUreInQ","tags":[]},{"title":"腾讯云部署java web项目过程.md","date":"2017-05-15T15:09:40.000Z","path":"2017/05/15/腾讯云部署java-web项目过程/","text":"在腾讯云上通过购买了云主机和域名以后,就把自己的”whatoeat”项目部署在上面,其中遇到了很多问题,现在记录下这个过程. 一. 搭建环境云主机上我选择的系统是windows server2008,采用腾讯云服务市场上自带MySQL 5.5 JDK6/7/8 和Tomecat6/7/8 以及FileZilla虽然软件都安装好了,但是环境还是要自己配置的.环境配置如下: 1 配置JDK环境变量（在步骤查看如何配置环境变量）1 新建变量名：JAVA_HOME，变量值：C:\\Program Files\\Java\\jdk1.7.02 打开PATH，添加变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin3 新建变量名：CLASSPATH，变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar备注： .表示当前路径，%JAVA_HOME%就是引用前面指定的JAVA_HOME； JAVA_HOME指明JDK安装路径，此路径下包括lib，bin，jre等文件夹，tomcat，eclipse等的运行都需要依靠此变量。 PATH使得系统可以在任何路径下识别java命令。 CLASSPATH为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别。2. 测试JDK在CMD命令下输入javac，java，javadoc命令：出现提示界面，表示安装成功。3. 配置Tomcat环境变量1 新建变量名：CATALINA_BASE，变量值：C:\\tomcat2 新建变量名：CATALINA_HOME，变量值：C:\\tomcat3 打开PATH，添加变量值：%CATALINA_HOME%\\lib;%CATALINA_HOME%\\bin4. 测试Tomcat在tomcat的安装目录下,启动startup,启动成功后打开浏览器，在地址栏中输入http://localhost:8080回车，如果看到Tomcat自带的一个JSP页面(猫)，说明你的JDK和Tomcat已搭建成功。 二. 部署项目1 将项目打包成 war 包并把数据库数据导出成sql文件,将war包和sql文件通过FileZilla上传到服务器中.2 在mysql命令行中使用 source +sql文件路径 命令导入数据3 将war包放入tomcat文件夹下的webapps目录,启动tomcat,tomcat会自动解压项目4 完成后在浏览器中放问 localhost:8080/项目名称 出现项目页面则成功 三. 域名解析在腾讯云的域名管理界面解析域名 四. 绑定域名如果有一个服务器已经部署好项目已做域名解析使用IP:8080/项目名称 能够访问项目 一般你这样做就能使用域名直接访问项目了: cd 到你的tomcat下修改server.xml文件中监听端口:修改前:1&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 修改后:1&lt;Connector port=\"80\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 也就是说将监听端口，修改为默认的80端口。 继续修改server.xml中Host找到1&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; 修改为：1&lt;Host name=\"你的域名\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; 以及在该…标签内添加标签1&lt;Context path=\"\" docBase=\"/myApp\" /&gt; docBase属性填写你的项目位置，最好是绝对路径即…../webapps/myApp。 whatoeat项目中,tomcat xml文件最终修改如下: 123456&lt;Host name=\"www.whatoeat.cn\" appBase=\"C:\\virtualhost\\dengtianyue\" unpackWARs=\"true\"autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\"&gt;&lt;Context path=\"/whaToEat\" docBase=\"C:\\virtualhost\\dengtianyue\\whaToEat\" reloadable=\"false\" source=\"org.eclipse.jst.jee.server:whaToEat\"/&gt; &lt;/Host&gt;&lt;/Engine&gt; &lt;Connector port=\"80\" redirectPort=\"8443\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\"/&gt;&lt;/Service&gt; 重启tomcat,打开浏览器,输入域名访问即可","tags":[]},{"title":"基于吃什么项目对MVC分层模型的学习","date":"2017-04-24T12:35:02.000Z","path":"2017/04/24/基于吃什么项目对MVC分层模型的学习/","text":"在做完”Whatoeat”这个项目后,对于MVC分层模型有了更深层次的了解 MVC分层模型: Whatoeat 的目录结构: 目录结构解析:src: action : 动作层,起控制器的作用—–取掉转 db : 数据库层.负责连接数据库,获得sessionFactory entity : 实体层,对应数据库表的实体类 service : 业务逻辑接口层 serviceimpl : 接口实现层 对数据进行一些操作 Test单元测试类,负责模块的测试 WebrootWeb应用部署后各文件的所在地,包括Web前端的css,js等和jsp文件.java文件编译后将保存于WEB-INF/class目录下","tags":[]},{"title":"新手使用github的心得","date":"2017-03-31T12:33:20.000Z","path":"2017/03/31/新手使用github的心得/","text":"作为一个新手最近开始使用github,记录一下自己初识github的心得 #1. 建立仓库建立仓库的过程不多说,登录到github网站以后,点击绿色的 New repository,然后按照步骤创建项目就可以了.创建的过程中可以选择是否自动生成readme文件. #2. 克隆仓库到本地 可以克隆的前提是已经配置好git和ssh,关于git和ssh的配置可以在网上搜索,有很多的大神分享=.= git配置好以后,在本地新建一个文件夹,在文件夹中鼠标右键,选择git bash,进入命令行后执行1git clone https://github.com/dengtianyue/whatToEat.git 这个网址就是你刚刚建立仓库以后,浏览器中显示的网址后添加”.git”就可以了,也可以进入仓库后,右侧有一个绿色的 Clone or download按钮,点击它也会出来这个url. 克隆成功后,会发现文件夹里已经多出了一个以仓库名为名字的文件夹.#3. 对文件夹进行git初始化12git initgit remote https://github.com/dengtianyue/whatToEat.git 初始化只要执行一次就够了,以后不需要再次执行.如果执行初始化过程中它提示 fatal: remote origin already exists说明已经配置过了,可以直接进行下一步 #4. push文件123git add . git commit -m &apos;备注,一定要写&apos; git push origin master 其中add 后可以加文件名 ,加一个.是指全部上传 如果执行 git push origin master 时报错:error:failed to push som refs to…则可以试着执行1git pull origin master 再执行1git push origin master 先把远程服务器github上面的文件拉先来，再push 上去。ps:这是一个新手初步使用github的心得,十分浅显.深入了解github的使用请参考网上大神们的教程=.=","tags":[]},{"title":"多对多关系的处理办法","date":"2017-03-31T11:36:05.000Z","path":"2017/03/31/多对多关系的处理办法/","text":"多对多关系的处理在数据库设计的过程中,经常会遇到两张表是多对多的关系.如订单和商品之间的关系:一个订单包含了很多商品,而一种商品同时也可能属于多个订单.这时就需要通过建立一个第三方关联表,将多对多关系拆分成两个一对多关系.其中关联表为多方. 实例如下:背景 一种菜品属于一个菜系,一个菜系也包括很多菜品; 一种菜品根据原材料分可以分为多个种类,如番茄炒蛋可以归为蛋类也可归为蔬菜类,而每个种类下也有多个菜品 通过建立菜系-菜品关联表,种类-菜品关联表来处理菜品与菜系,菜品与种类之间的多对多关系 数据表名词解释: food:菜品 foodstyle:菜系 foodtype:种类 stylelink:菜系-菜品关联表 typelink:种类-菜品关联表 对应的ER图如下:","tags":[]},{"title":"Hibernate中配置映射关系","date":"2017-03-31T11:06:43.000Z","path":"2017/03/31/Hibernate中配置映射关系/","text":"Hibernate中配置映射关系准备工作 进行Hibernate的基本配置 创建HibernateUtil工具类 进行数据表的建立 创建持久化类和映射关系文件 配置单向一对多关系使用标签在一方的hbm.xml文件中,配置单向的一对多映射,如:123456789&lt;!-- 配置单向的一对多映射 设置inverse属性为true 由多方维护关联关系 , 设置cascade=\"save-update\",当进行保存和更新时级联操作所关联的对象--&gt; &lt;set name=\"students\" table=\"student\" inverse=\"false\" lazy=\"true\" cascade=\"save-update\"&gt; &lt;!-- 指定关联的外键列 --&gt; &lt;key&gt; &lt;column name=\"gid\" /&gt; &lt;/key&gt; &lt;one-to-many class=\"entity.Student\" /&gt; &lt;/set&gt; 测试类:1234567891011121314151617181920212223242526272829//将学生添加到班级public static void add()&#123; Grade g = new Grade(\"JAVA1\",\"JAVA软件开发一班\"); Student stu1 = new Student(\"张三\",\"男\"); Student stu2 = new Student(\"青青\",\"男\"); //如果希望在学生表中添加对应的班级编号,需要在班级中添加学生,建立关联关系 g.getStudents().add(stu1); g.getStudents().add(stu2); Session session = HibernateUtil.getSession(); Transaction tx = session.beginTransaction(); session.save(g); session.save(stu1); session.save(stu2); tx.commit(); HibernateUtil.closeSession(session);&#125;//查询班级学生信息public static void findStudentsByGrade()&#123; Session session = HibernateUtil.getSession(); Grade grade = (Grade) session.get(Grade.class, 1); System.out.println(grade.getGname()+\",\"+grade.getGdesc()); Set&lt;Student&gt;students = grade.getStudents(); for(Student stu : students)&#123; System.out.println(stu.getSname()+\",\"+stu.getSex()); &#125;&#125; 单向多对一的配置在多方的hbm.xml文件中,使用标签配置如:12&lt;!-- 配置多对一关联配置 --&gt; &lt;many-to-one name=\"grade\" class = \"entity.Grade\" column=\"gid\"&gt;&lt;/many-to-one&gt; 当双方关系都配置好后,即双向映射已经配置测试:1234567891011121314151617181920212223242526272829303132//保存,测试多对一映射public static void save()&#123; Grade g = new Grade(\"JAVA1\",\"JAVA软件开发一班\"); Student stu1 = new Student(\"呵呵\",\"男\"); Student stu2 = new Student(\"小美\",\"女\"); //设置关联关系 g.getStudents().add(stu1); g.getStudents().add(stu2); stu1.setGrade(g); stu2.setGrade(g); Session session = HibernateUtil.getSession(); Transaction tx = session.beginTransaction(); session.save(g); //session.save(stu1); //session.save(stu2); tx.commit(); HibernateUtil.closeSession(session);&#125; //双向多对一测试public static void findGradeByStudent()&#123; Session session = HibernateUtil.getSession(); Student stu = (Student) session.get(Student.class, 2); Grade grade = stu.getGrade(); System.out.println(stu.getSid()+\",\"+stu.getSname()+\",\"+stu.getSex()); System.out.println(grade.getGid()+\",\"+grade.getGname()+\",\"+grade.getGdesc()); HibernateUtil.closeSession(session);&#125; 相关知识点:1.inverse属性的用法在一对多关联关系中默认有one方维护关联关系，因为是双向一对多关联关系，所以one方需进行两次关联关系的维护，当在one方设置inverse属性值为true时，反转，即让多方进行关联关系的维护，此时不需要执行update 多方表名（student） set 单方表的主键（多方表中的外键即gid）等于单方某记录的gid值当sid为值一，sid为值二，，，，（student表中有n个记录则需执行n次操作）这些操作，所以当在one方设置inverse属性值为true时有利于改善系统性能。 2.cascade属性的用法 当设置cascade属性部位none时,Hibernate会自动持久化所关联的对象 cascade属性的常用设置: all—&gt;对所有操作进行级联操作 save-update–&gt;执行保存和更新操作时进行级联操作 delete–&gt;执行删除操作时进行级联操作 none–&gt;对所有操作不进行级联操作","tags":[]},{"title":"Hibernate的基本用法","date":"2017-03-29T16:28:42.000Z","path":"2017/03/30/Hibernate的基本用法/","text":"Hibernate 的基本开发步骤1.编写配置文档hibernat.cfg.xml例如:1234567891011121314151617181920&lt;session-factory&gt; &lt;!--数据库用户名--&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;!--数据库登录密码--&gt; &lt;property name=\"connection.password\"&gt;123456&lt;/property&gt; &lt;!--jdbc驱动 --&gt; &lt;property name=\"connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--设置端口 字符集等 --&gt; &lt;property name=\"connection.url\"&gt;jdbc:mysql://127.0.0.1:3306/hibernate?useUnicode=true&amp;characterEncoding=utf-8&lt;/property&gt; &lt;!--方言 --&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!--是否直接打印出sql语句 --&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!--sql格式 --&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;!--ddl生成策略--&gt; &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!--对应的映射 --&gt; &lt;mapping resource=\"Students.hbm.xml\"/&gt; &lt;/session-factory&gt; 单一主键:1.assigned 由java应用程序负责生成（手工赋值） 2.native 由底层数据库自动生成标示符，如果是MySQL就是increment，如果是Oracle就是sequence，等等 Ps1：assigned注意：如果实体类中设置的主键id是基本类型int的话，则可以不用赋值，系统默认值为0；如是引用类型Integer话，则默认值为null，不赋值系统则报错。 Ps2：native注意：系统会自动选择该数据库对应的自动增值方式，从1开始。即使手动给他赋值，也不会起作用，但也不会报错。 2.编写实体类需要符合JAVA BEAN 规范 即:1、公有的类。2、提供公有的不带参数的默认的构造方法。3、属性私有。4、属性setter/getter封装 3.生成对应实体类的映射文件可在包上鼠标右键,点击new-&gt;other-&gt;Hibernate-&gt;Hibernate XML Mapping file(hbm.xml)自动创建如:1234567891011121314151617181920212223242526&lt;hibernate-mapping&gt; &lt;class name=\"Students\" table=\"STUDENTS\"&gt; &lt;id name=\"id\" type=\"int\"&gt; &lt;column name=\"ID\" /&gt; &lt;!--主键策略--&gt; &lt;generator class=\"assigned\" /&gt; &lt;/id&gt; &lt;property name=\"sname\" type=\"java.lang.String\"&gt; &lt;column name=\"SNAME\" /&gt; &lt;/property&gt; ...................... &lt;!-- &lt;property name=\"address\" type=\"java.lang.String\"&gt; &lt;column name=\"ADDRESS\" /&gt; &lt;/property&gt; --&gt; &lt;property name=\"picture\" type=\"java.sql.Blob\"&gt; &lt;column name=\"PICTURE\" /&gt; &lt;/property&gt; &lt;component name=\"address\" class=\"Address\"&gt; &lt;property name=\"postcode\" column=\"POSTCODE\"/&gt; &lt;property name=\"phone\" column=\"PHONE\"/&gt; &lt;property name=\"address\" column=\"ADDRESS\"/&gt; &lt;/component&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 常用配置如下:4.调用Hibernate API进行测试例如:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.sql.Blob;import java.util.Date;import org.hibernate.Hibernate;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;import org.hibernate.service.ServiceRegistryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;//测试类public class StudentsTest &#123; private SessionFactory sessionFactory; private Session session; private Transaction transaction; @Before public void init()&#123; //创建配置对象 Configuration config = new Configuration().configure(); //创建服务注册对象 ServiceRegistry serviceRegistry = new ServiceRegistryBuilder().applySettings(config.getProperties()).buildServiceRegistry(); //创建会话工厂对象 sessionFactory = config.buildSessionFactory(serviceRegistry); //会话对象 session = sessionFactory.openSession(); //开启事务 transaction = session.beginTransaction(); &#125; @After public void distory()&#123; //提交事务 transaction.commit(); session.close(); sessionFactory.close(); &#125; @Test public void testSaveStudents()&#123; //生成学生对象 Students s = new Students(1,\"小明\",\"男\",new Date()); Address address = new Address(\"312312\",\"09876666\",\"杭州\"); s.setAddress(address); session.save(s);//保存对象进入数据库 &#125; @Test public void testWriteBlob()throws Exception&#123; Students s = new Students(4,\"小明\",\"男\",new Date()); //获得照片文件 File f = new File(\"f:\"+File.separator+\"头像.jpg\"); //获得输入流 InputStream input = new FileInputStream(f); //创建一个Blob对象 Blob image = Hibernate.getLobCreator(session).createBlob(input, input.available()); //设置照片属性 s.setPicture(image); //保存学生 session.save(s); &#125; @Test public void testReadBlob()throws Exception &#123; Students s = (Students) session.get(Students.class, 4); //获得blob对象 Blob image =s.getPicture(); //创建输入流 InputStream input = image.getBinaryStream(); //创建输出流 File f = new File(\"f:\"+File.separator+\"头像2.jpg\"); OutputStream output = new FileOutputStream(f); //缓冲区 byte[] buff = new byte[input.available()]; input.read(buff); output.write(buff); input.close(); output.close(); &#125; Hibernate其他一些基础知识transaction：事务Hibernate对数据的操作都是封装在事务当中，并且默认是非自动提交的方式。所以用session保存对象时，如果不开启事务，并且手工提交事务，对象并不会真正保存在数据库中 如上例中的： 1234 //开启事务transaction = session.beginTransaction(); //提交事务transaction.commit(); session1.getCurrentSession在事务提交或者回滚之后会自动关闭，而openSesssion需要你手动关闭。如果使用openSession而没有手动关闭，多次之后会导致连接池溢出！2.openSession每次创建新的session对象，getCurrentSession使用现有的session对象（现有session没commit之前） 基本类型 对象类型","tags":[]},{"title":"Hello World","date":"2017-03-29T03:19:08.088Z","path":"2017/03/29/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]