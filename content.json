[{"title":"腾讯云部署java web项目过程.md","date":"2017-05-15T15:09:40.000Z","path":"2017/05/15/腾讯云部署java-web项目过程/","text":"在腾讯云上通过购买了云主机和域名以后,就把自己的”whatoeat”项目部署在上面,其中遇到了很多问题,现在记录下这个过程. 一. 搭建环境云主机上我选择的系统是windows server2008,采用腾讯云服务市场上自带MySQL 5.5 JDK6/7/8 和Tomecat6/7/8 以及FileZilla虽然软件都安装好了,但是环境还是要自己配置的.环境配置如下: 1 配置JDK环境变量（在步骤查看如何配置环境变量）1 新建变量名：JAVA_HOME，变量值：C:\\Program Files\\Java\\jdk1.7.02 打开PATH，添加变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin3 新建变量名：CLASSPATH，变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar备注： .表示当前路径，%JAVA_HOME%就是引用前面指定的JAVA_HOME； JAVA_HOME指明JDK安装路径，此路径下包括lib，bin，jre等文件夹，tomcat，eclipse等的运行都需要依靠此变量。 PATH使得系统可以在任何路径下识别java命令。 CLASSPATH为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别。2. 测试JDK在CMD命令下输入javac，java，javadoc命令：出现提示界面，表示安装成功。3. 配置Tomcat环境变量1 新建变量名：CATALINA_BASE，变量值：C:\\tomcat2 新建变量名：CATALINA_HOME，变量值：C:\\tomcat3 打开PATH，添加变量值：%CATALINA_HOME%\\lib;%CATALINA_HOME%\\bin4. 测试Tomcat在tomcat的安装目录下,启动startup,启动成功后打开浏览器，在地址栏中输入http://localhost:8080回车，如果看到Tomcat自带的一个JSP页面(猫)，说明你的JDK和Tomcat已搭建成功。 二. 部署项目1 将项目打包成 war 包并把数据库数据导出成sql文件,将war包和sql文件通过FileZilla上传到服务器中.2 在mysql命令行中使用 source +sql文件路径 命令导入数据3 将war包放入tomcat文件夹下的webapps目录,启动tomcat,tomcat会自动解压项目4 完成后在浏览器中放问 localhost:8080/项目名称 出现项目页面则成功 三. 域名解析在腾讯云的域名管理界面解析域名 四. 绑定域名如果有一个服务器已经部署好项目已做域名解析使用IP:8080/项目名称 能够访问项目 一般你这样做就能使用域名直接访问项目了: cd 到你的tomcat下修改server.xml文件中监听端口:修改前:1&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 修改后:1&lt;Connector port=\"80\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 也就是说将监听端口，修改为默认的80端口。 继续修改server.xml中Host找到1&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; 修改为：1&lt;Host name=\"你的域名\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; 以及在该…标签内添加标签1&lt;Context path=\"\" docBase=\"/myApp\" /&gt; docBase属性填写你的项目位置，最好是绝对路径即…../webapps/myApp。 whatoeat项目中,tomcat xml文件最终修改如下: 123456&lt;Host name=\"www.whatoeat.cn\" appBase=\"C:\\virtualhost\\dengtianyue\" unpackWARs=\"true\"autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\"&gt;&lt;Context path=\"/whaToEat\" docBase=\"C:\\virtualhost\\dengtianyue\\whaToEat\" reloadable=\"false\" source=\"org.eclipse.jst.jee.server:whaToEat\"/&gt; &lt;/Host&gt;&lt;/Engine&gt; &lt;Connector port=\"80\" redirectPort=\"8443\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\"/&gt;&lt;/Service&gt; 重启tomcat,打开浏览器,输入域名访问即可","tags":[]},{"title":"基于吃什么项目对MVC分层模型的学习","date":"2017-04-24T12:35:02.000Z","path":"2017/04/24/基于吃什么项目对MVC分层模型的学习/","text":"在做完”Whatoeat”这个项目后,对于MVC分层模型有了更深层次的了解 MVC分层模型: Whatoeat 的目录结构: 目录结构解析:src: action : 动作层,起控制器的作用—–取掉转 db : 数据库层.负责连接数据库,获得sessionFactory entity : 实体层,对应数据库表的实体类 service : 业务逻辑接口层 serviceimpl : 接口实现层 对数据进行一些操作 Test单元测试类,负责模块的测试 WebrootWeb应用部署后各文件的所在地,包括Web前端的css,js等和jsp文件.java文件编译后将保存于WEB-INF/class目录下","tags":[]},{"title":"新手使用github的心得","date":"2017-03-31T12:33:20.000Z","path":"2017/03/31/新手使用github的心得/","text":"作为一个新手最近开始使用github,记录一下自己初识github的心得 #1. 建立仓库建立仓库的过程不多说,登录到github网站以后,点击绿色的 New repository,然后按照步骤创建项目就可以了.创建的过程中可以选择是否自动生成readme文件. #2. 克隆仓库到本地 可以克隆的前提是已经配置好git和ssh,关于git和ssh的配置可以在网上搜索,有很多的大神分享=.= git配置好以后,在本地新建一个文件夹,在文件夹中鼠标右键,选择git bash,进入命令行后执行1git clone https://github.com/dengtianyue/whatToEat.git 这个网址就是你刚刚建立仓库以后,浏览器中显示的网址后添加”.git”就可以了,也可以进入仓库后,右侧有一个绿色的 Clone or download按钮,点击它也会出来这个url. 克隆成功后,会发现文件夹里已经多出了一个以仓库名为名字的文件夹.#3. 对文件夹进行git初始化12git initgit remote https://github.com/dengtianyue/whatToEat.git 初始化只要执行一次就够了,以后不需要再次执行.如果执行初始化过程中它提示 fatal: remote origin already exists说明已经配置过了,可以直接进行下一步 #4. push文件123git add . git commit -m '备注,一定要写' git push origin master 其中add 后可以加文件名 ,加一个.是指全部上传 如果执行 git push origin master 时报错:error:failed to push som refs to…则可以试着执行1git pull origin master 再执行1git push origin master 先把远程服务器github上面的文件拉先来，再push 上去。ps:这是一个新手初步使用github的心得,十分浅显.深入了解github的使用请参考网上大神们的教程=.=","tags":[]},{"title":"多对多关系的处理办法","date":"2017-03-31T11:36:05.000Z","path":"2017/03/31/多对多关系的处理办法/","text":"多对多关系的处理在数据库设计的过程中,经常会遇到两张表是多对多的关系.如订单和商品之间的关系:一个订单包含了很多商品,而一种商品同时也可能属于多个订单.这时就需要通过建立一个第三方关联表,将多对多关系拆分成两个一对多关系.其中关联表为多方. 实例如下:背景 一种菜品属于一个菜系,一个菜系也包括很多菜品; 一种菜品根据原材料分可以分为多个种类,如番茄炒蛋可以归为蛋类也可归为蔬菜类,而每个种类下也有多个菜品 通过建立菜系-菜品关联表,种类-菜品关联表来处理菜品与菜系,菜品与种类之间的多对多关系 数据表名词解释: food:菜品 foodstyle:菜系 foodtype:种类 stylelink:菜系-菜品关联表 typelink:种类-菜品关联表 对应的ER图如下:","tags":[]},{"title":"Hibernate中配置映射关系","date":"2017-03-31T11:06:43.000Z","path":"2017/03/31/Hibernate中配置映射关系/","text":"Hibernate中配置映射关系准备工作 进行Hibernate的基本配置 创建HibernateUtil工具类 进行数据表的建立 创建持久化类和映射关系文件 配置单向一对多关系使用标签在一方的hbm.xml文件中,配置单向的一对多映射,如:123456789&lt;!-- 配置单向的一对多映射 设置inverse属性为true 由多方维护关联关系 , 设置cascade=\"save-update\",当进行保存和更新时级联操作所关联的对象--&gt; &lt;set name=\"students\" table=\"student\" inverse=\"false\" lazy=\"true\" cascade=\"save-update\"&gt; &lt;!-- 指定关联的外键列 --&gt; &lt;key&gt; &lt;column name=\"gid\" /&gt; &lt;/key&gt; &lt;one-to-many class=\"entity.Student\" /&gt; &lt;/set&gt; 测试类:1234567891011121314151617181920212223242526272829//将学生添加到班级public static void add()&#123; Grade g = new Grade(\"JAVA1\",\"JAVA软件开发一班\"); Student stu1 = new Student(\"张三\",\"男\"); Student stu2 = new Student(\"青青\",\"男\"); //如果希望在学生表中添加对应的班级编号,需要在班级中添加学生,建立关联关系 g.getStudents().add(stu1); g.getStudents().add(stu2); Session session = HibernateUtil.getSession(); Transaction tx = session.beginTransaction(); session.save(g); session.save(stu1); session.save(stu2); tx.commit(); HibernateUtil.closeSession(session);&#125;//查询班级学生信息public static void findStudentsByGrade()&#123; Session session = HibernateUtil.getSession(); Grade grade = (Grade) session.get(Grade.class, 1); System.out.println(grade.getGname()+\",\"+grade.getGdesc()); Set&lt;Student&gt;students = grade.getStudents(); for(Student stu : students)&#123; System.out.println(stu.getSname()+\",\"+stu.getSex()); &#125;&#125; 单向多对一的配置在多方的hbm.xml文件中,使用标签配置如:12&lt;!-- 配置多对一关联配置 --&gt; &lt;many-to-one name=\"grade\" class = \"entity.Grade\" column=\"gid\"&gt;&lt;/many-to-one&gt; 当双方关系都配置好后,即双向映射已经配置测试:1234567891011121314151617181920212223242526272829303132//保存,测试多对一映射public static void save()&#123; Grade g = new Grade(\"JAVA1\",\"JAVA软件开发一班\"); Student stu1 = new Student(\"呵呵\",\"男\"); Student stu2 = new Student(\"小美\",\"女\"); //设置关联关系 g.getStudents().add(stu1); g.getStudents().add(stu2); stu1.setGrade(g); stu2.setGrade(g); Session session = HibernateUtil.getSession(); Transaction tx = session.beginTransaction(); session.save(g); //session.save(stu1); //session.save(stu2); tx.commit(); HibernateUtil.closeSession(session);&#125; //双向多对一测试public static void findGradeByStudent()&#123; Session session = HibernateUtil.getSession(); Student stu = (Student) session.get(Student.class, 2); Grade grade = stu.getGrade(); System.out.println(stu.getSid()+\",\"+stu.getSname()+\",\"+stu.getSex()); System.out.println(grade.getGid()+\",\"+grade.getGname()+\",\"+grade.getGdesc()); HibernateUtil.closeSession(session);&#125; 相关知识点:1.inverse属性的用法在一对多关联关系中默认有one方维护关联关系，因为是双向一对多关联关系，所以one方需进行两次关联关系的维护，当在one方设置inverse属性值为true时，反转，即让多方进行关联关系的维护，此时不需要执行update 多方表名（student） set 单方表的主键（多方表中的外键即gid）等于单方某记录的gid值当sid为值一，sid为值二，，，，（student表中有n个记录则需执行n次操作）这些操作，所以当在one方设置inverse属性值为true时有利于改善系统性能。 2.cascade属性的用法 当设置cascade属性部位none时,Hibernate会自动持久化所关联的对象 cascade属性的常用设置: all—&gt;对所有操作进行级联操作 save-update–&gt;执行保存和更新操作时进行级联操作 delete–&gt;执行删除操作时进行级联操作 none–&gt;对所有操作不进行级联操作","tags":[]},{"title":"Hibernate的基本用法","date":"2017-03-29T16:28:42.000Z","path":"2017/03/30/Hibernate的基本用法/","text":"Hibernate 的基本开发步骤1.编写配置文档hibernat.cfg.xml例如:1234567891011121314151617181920&lt;session-factory&gt; &lt;!--数据库用户名--&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;!--数据库登录密码--&gt; &lt;property name=\"connection.password\"&gt;123456&lt;/property&gt; &lt;!--jdbc驱动 --&gt; &lt;property name=\"connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--设置端口 字符集等 --&gt; &lt;property name=\"connection.url\"&gt;jdbc:mysql://127.0.0.1:3306/hibernate?useUnicode=true&amp;characterEncoding=utf-8&lt;/property&gt; &lt;!--方言 --&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!--是否直接打印出sql语句 --&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!--sql格式 --&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;!--ddl生成策略--&gt; &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!--对应的映射 --&gt; &lt;mapping resource=\"Students.hbm.xml\"/&gt; &lt;/session-factory&gt; 单一主键:1.assigned 由java应用程序负责生成（手工赋值） 2.native 由底层数据库自动生成标示符，如果是MySQL就是increment，如果是Oracle就是sequence，等等 Ps1：assigned注意：如果实体类中设置的主键id是基本类型int的话，则可以不用赋值，系统默认值为0；如是引用类型Integer话，则默认值为null，不赋值系统则报错。 Ps2：native注意：系统会自动选择该数据库对应的自动增值方式，从1开始。即使手动给他赋值，也不会起作用，但也不会报错。 2.编写实体类需要符合JAVA BEAN 规范 即:1、公有的类。2、提供公有的不带参数的默认的构造方法。3、属性私有。4、属性setter/getter封装 3.生成对应实体类的映射文件可在包上鼠标右键,点击new-&gt;other-&gt;Hibernate-&gt;Hibernate XML Mapping file(hbm.xml)自动创建如:1234567891011121314151617181920212223242526&lt;hibernate-mapping&gt; &lt;class name=\"Students\" table=\"STUDENTS\"&gt; &lt;id name=\"id\" type=\"int\"&gt; &lt;column name=\"ID\" /&gt; &lt;!--主键策略--&gt; &lt;generator class=\"assigned\" /&gt; &lt;/id&gt; &lt;property name=\"sname\" type=\"java.lang.String\"&gt; &lt;column name=\"SNAME\" /&gt; &lt;/property&gt; ...................... &lt;!-- &lt;property name=\"address\" type=\"java.lang.String\"&gt; &lt;column name=\"ADDRESS\" /&gt; &lt;/property&gt; --&gt; &lt;property name=\"picture\" type=\"java.sql.Blob\"&gt; &lt;column name=\"PICTURE\" /&gt; &lt;/property&gt; &lt;component name=\"address\" class=\"Address\"&gt; &lt;property name=\"postcode\" column=\"POSTCODE\"/&gt; &lt;property name=\"phone\" column=\"PHONE\"/&gt; &lt;property name=\"address\" column=\"ADDRESS\"/&gt; &lt;/component&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 常用配置如下:4.调用Hibernate API进行测试例如:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.sql.Blob;import java.util.Date;import org.hibernate.Hibernate;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;import org.hibernate.service.ServiceRegistryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;//测试类public class StudentsTest &#123; private SessionFactory sessionFactory; private Session session; private Transaction transaction; @Before public void init()&#123; //创建配置对象 Configuration config = new Configuration().configure(); //创建服务注册对象 ServiceRegistry serviceRegistry = new ServiceRegistryBuilder().applySettings(config.getProperties()).buildServiceRegistry(); //创建会话工厂对象 sessionFactory = config.buildSessionFactory(serviceRegistry); //会话对象 session = sessionFactory.openSession(); //开启事务 transaction = session.beginTransaction(); &#125; @After public void distory()&#123; //提交事务 transaction.commit(); session.close(); sessionFactory.close(); &#125; @Test public void testSaveStudents()&#123; //生成学生对象 Students s = new Students(1,\"小明\",\"男\",new Date()); Address address = new Address(\"312312\",\"09876666\",\"杭州\"); s.setAddress(address); session.save(s);//保存对象进入数据库 &#125; @Test public void testWriteBlob()throws Exception&#123; Students s = new Students(4,\"小明\",\"男\",new Date()); //获得照片文件 File f = new File(\"f:\"+File.separator+\"头像.jpg\"); //获得输入流 InputStream input = new FileInputStream(f); //创建一个Blob对象 Blob image = Hibernate.getLobCreator(session).createBlob(input, input.available()); //设置照片属性 s.setPicture(image); //保存学生 session.save(s); &#125; @Test public void testReadBlob()throws Exception &#123; Students s = (Students) session.get(Students.class, 4); //获得blob对象 Blob image =s.getPicture(); //创建输入流 InputStream input = image.getBinaryStream(); //创建输出流 File f = new File(\"f:\"+File.separator+\"头像2.jpg\"); OutputStream output = new FileOutputStream(f); //缓冲区 byte[] buff = new byte[input.available()]; input.read(buff); output.write(buff); input.close(); output.close(); &#125; Hibernate其他一些基础知识transaction：事务Hibernate对数据的操作都是封装在事务当中，并且默认是非自动提交的方式。所以用session保存对象时，如果不开启事务，并且手工提交事务，对象并不会真正保存在数据库中 如上例中的： 1234 //开启事务transaction = session.beginTransaction(); //提交事务transaction.commit(); session1.getCurrentSession在事务提交或者回滚之后会自动关闭，而openSesssion需要你手动关闭。如果使用openSession而没有手动关闭，多次之后会导致连接池溢出！2.openSession每次创建新的session对象，getCurrentSession使用现有的session对象（现有session没commit之前） 基本类型 对象类型","tags":[]},{"title":"Hello World","date":"2017-03-29T03:19:08.088Z","path":"2017/03/29/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]