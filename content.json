[{"title":"Struts-通配符","date":"2017-07-18T08:11:37.000Z","path":"2017/07/18/Struts-通配符/","text":"Struts2使用通配符配置可以减少action的配置例如:123456789101112&lt;package name=\"foods\" namespace=\"/foods\" extends=\"struts-default\"&gt; &lt;action name=\"*_*\" class=\"action.&#123;1&#125;Action\" method = \"&#123;2&#125;\"&gt; &lt;result name=\"queryWhatoeat_success\"&gt;/foods/queryWhatoeat_success.jsp&lt;/result&gt; &lt;result name=\"queryWhatoeat2_success\"&gt;/foods/queryWhatoeat_success2.jsp&lt;/result&gt; &lt;result name=\"queryLikeFoods_success\"&gt;/foods/queryLikeFoods_success.jsp&lt;/result&gt; &lt;result name=\"queryDislikeFoods_success\"&gt;/foods/queryDislikeFoods_success.jsp&lt;/result&gt; &lt;result name=\"addLikeFoods_success\" &gt;/foods/queryWhatoeat_success.jsp&lt;/result&gt; &lt;result name=\"addDislikeFoods_success\" &gt;/foods/queryWhatoeat_success.jsp&lt;/result&gt; &lt;result name=\"deleteLikeFoods_success\" &gt;/foods/queryWhatoeat_success.jsp&lt;/result&gt; &lt;result name=\"deleteDislikeFoods_success\" &gt;/foods/queryWhatoeat_success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 在jsp中其对应的映射为:1&lt;a href=\"&lt;%=path%&gt;/foods/Foods_addLikeFoods.action&gt;喜欢&lt;/a&gt; 在此链接中 /foods 对应 xml中的 namespaceFoods_addLikeFoods.action 中Foods 对应xml中的第一个,作用于 class=”action.{1}Action 中的{1}位置addLikeFoods 对应第二个,作用于 method = “{2}” 中的{2}位置 则此例相当于配置action:123&lt;package name=\"foods\" namespace=\"/foods\" extends=\"struts-default\"&gt; &lt;action name=\"Foods_addLikeFoods\" class=\"action.FoodsAction\" method = \"addLikeFoods\"&gt;&lt;/action&gt;&lt;/package&gt;","tags":[]},{"title":"Struts入门及使用gson将数据转为json格式","date":"2017-07-18T07:57:17.000Z","path":"2017/07/18/Struts入门及使用gson将数据转为json格式/","text":"Gson 是 Google 提供的用来在 Java 对象和 JSON 数据之间进行映射的 Java 类库。可以将一个 JSON 字符串转成一个 Java 对象，或者反过来将JSON格式解析 Gson的基本用法Gson提供了fromJson() 和toJson() 两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HelloWorldAction extends SuperAction &#123; /** * */ private static final long serialVersionUID = 1L; @Override public String execute()&#123; //创建Gson对象 Gson gson = new Gson(); //将对象类型转为jsonObject,并传入session中 System.out.println(\"===============jsonObject===================\"); Student student = new Student(); student.setAge(12); student.setGender(\"男\"); student.setId(\"2333333\"); student.setName(\"orz\"); student.setEmailAddress(\"123123@2333.com\"); String jsonObject = gson.toJson(student); session.setAttribute(\"jsonObject\", jsonObject); //将list转为json格式,并传入session中 System.out.println(\"===============jsonList===================\"); Student student2 = new Student(); student2.setAge(14); student2.setGender(\"男\"); student2.setId(\"2332312312312333\"); student2.setName(\"o2333z\"); student2.setEmailAddress(\"66623@888.com\"); List&lt;Student&gt;students = new ArrayList&lt;Student&gt;(); students.add(student); students.add(student2); String jsonList = gson.toJson(students); session.setAttribute(\"jsonList\", jsonList); //将数组转为jsonArray并传入session中 System.out.println(\"===============jsonArray===================\"); String[] s = &#123;\"233\",\"哈哈哈\",\"31233地方\"&#125;; String jsonArray = gson.toJson(s); session.setAttribute(\"jsonArray\", jsonArray); //解析json System.out.println(\"==============解析json====================\"); Student student3 = gson.fromJson(jsonObject, Student.class); System.out.println(student3.toString()); return \"execute_success\"; &#125;&#125; jsp获得数据1234&lt;s:property value=\"#session.jsonObject\"/&gt;&lt;br&gt;&lt;s:property value=\"#session.jsonArray\"/&gt;&lt;br&gt;&lt;s:iterator value=\"#session.jsonList\" var =\"slist\"&gt;&lt;s:property value=\"#slist\"/&gt; Struts的基本用法1.配置web.xml文件12345678&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2.编写action文件,返回一个结果值A,如下列的 “execute_success”123456789101112public class HelloWorldAction extends SuperAction &#123; /** * */ @Override public String execute()&#123; return \"execute_success\"; &#125;&#125; 3.配置struts.xml文件123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.1//EN\" \"http://struts.apache.org/dtds/struts-2.1.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"helloworld\" class=\"action.HelloWorldAction\" method = \"execute\"&gt; &lt;result name=\"execute_success\"&gt;/result.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 4.在jsp文件中配置执行的动作1&lt;a href=\"helloworld\"&gt;test&lt;/a&gt;","tags":[]},{"title":"'学习Spring的第一个HelloWorld'","date":"2017-05-17T03:09:57.000Z","path":"2017/05/17/学习Spring的第一个HelloWorld/","text":"1 配置Spring新建一个java工程,导入如下包: 2 开始Spring编程1 新建一个HelloWorld.java1234567891011package test;public class HelloWorld &#123; private String info ; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125;&#125; 2 编写配置文件applicationContext.xml在当前工程下创建一个xml文件,添加如下代码123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- 配置需要被Spring管理的Bean（创建，创建后放在了Spring IOC容器里面）--&gt; &lt;bean id=\"hello\" class=\"test.HelloWorld\"&gt; &lt;!-- 配置该Bean需要注入的属性（是通过属性set方法来注入的） --&gt; &lt;property name=\"info\" value=\"Hello World!\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 3 反转控制开始在Main.java中添加如下：12345678910111213141516171819package test;import org.springframework.beans.factory.BeanFactory;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; //获取Spring的ApplicationContext配置文件，注入IOC容器中 //(Map: key:String, bean标签的id属性值 ==&gt;value:Object, bean标签class属性所指类的实例) BeanFactory factory = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); /* HelloWorld hw1 = new HelloWorld(); hw1.setInfo(\"Hello World!\"); */ //Spring相当于如上代码,通过getBean获取xml文件中对应id值的Bean,在xml文件中配置该Bean需要注入的属性 //不需要自己new对象以及赋值. HelloWorld hw1 = (HelloWorld)factory.getBean(\"hello\");//map.get(\"hello\") System.out.println(hw1.getInfo()); System.out.println(hw1); &#125;&#125; 3 测试结果 3 总结Spring可以通过配置的方法取得对象，而不再用new的方法来取得对象 先在xml配置文件中配置bean标签,如:1234&lt;bean id=\"hello\" class=\"test.HelloWorld\"&gt; &lt;!-- 配置该Bean需要注入的属性（是通过属性set方法来注入的） --&gt; &lt;property name=\"info\" value=\"Hello World!\"/&gt; &lt;/bean&gt; 其中id 为bean的key,通过之后getBean()取得配置的Bean.class 为创建的类所在包+类名property标签为该Bean配置注入的属性. 反转控制 1 通过1BeanFactory factory = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 来获取配置文件2 通过getBean获取xml文件中对应id值的Bean,就可以取得我们想要得到的对象了.","tags":[]},{"title":"hexo常用命令","date":"2017-05-15T15:17:09.000Z","path":"2017/05/15/hexo常用命令/","text":"简写hexo n == hexo new hexo p == hexo publish hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate –deploy hexo deploy –generatehexo deploy -g hexo server -g草稿hexo publish [layout] &lt;title&gt; 模版hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] hexo new photo “My Gallery” hexo new “Hello World” –lang tw变量 描述layout 布局title 标题date 文件建立日期title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。模版（Scaffold）hexo new photo &quot;My Gallery&quot; 变量 描述layout 布局title 标题date 文件建立日期写作hexo new page hexo new post 变量 描述:title 标题:year 建立的年份（4 位数）:month 建立的月份（2 位数）:i_month 建立的月份（去掉开头的零）:day 建立的日期（2 位数）:i_day 建立的日期（去掉开头的零）推送到服务器上hexo n #写文章 hexo g #生成 hexo d #部署 #可与 hexo g 合并为 hexo d -g 报错1.ERROR Deployer not found: gitnpm install hexo-deployer-git –save 来源： http://www.tuicool.com/articles/yUreInQ","tags":[]},{"title":"腾讯云部署java web项目过程.md","date":"2017-05-15T15:09:40.000Z","path":"2017/05/15/腾讯云部署java-web项目过程/","text":"在腾讯云上通过购买了云主机和域名以后,就把自己的”whatoeat”项目部署在上面,其中遇到了很多问题,现在记录下这个过程. 一. 搭建环境云主机上我选择的系统是windows server2008,采用腾讯云服务市场上自带MySQL 5.5 JDK6/7/8 和Tomecat6/7/8 以及FileZilla虽然软件都安装好了,但是环境还是要自己配置的.环境配置如下: 1 配置JDK环境变量（在步骤查看如何配置环境变量）1 新建变量名：JAVA_HOME，变量值：C:\\Program Files\\Java\\jdk1.7.02 打开PATH，添加变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin3 新建变量名：CLASSPATH，变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar备注： .表示当前路径，%JAVA_HOME%就是引用前面指定的JAVA_HOME； JAVA_HOME指明JDK安装路径，此路径下包括lib，bin，jre等文件夹，tomcat，eclipse等的运行都需要依靠此变量。 PATH使得系统可以在任何路径下识别java命令。 CLASSPATH为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别。2. 测试JDK在CMD命令下输入javac，java，javadoc命令：出现提示界面，表示安装成功。3. 配置Tomcat环境变量1 新建变量名：CATALINA_BASE，变量值：C:\\tomcat2 新建变量名：CATALINA_HOME，变量值：C:\\tomcat3 打开PATH，添加变量值：%CATALINA_HOME%\\lib;%CATALINA_HOME%\\bin4. 测试Tomcat在tomcat的安装目录下,启动startup,启动成功后打开浏览器，在地址栏中输入http://localhost:8080回车，如果看到Tomcat自带的一个JSP页面(猫)，说明你的JDK和Tomcat已搭建成功。 二. 部署项目1 将项目打包成 war 包并把数据库数据导出成sql文件,将war包和sql文件通过FileZilla上传到服务器中.2 在mysql命令行中使用 source +sql文件路径 命令导入数据3 将war包放入tomcat文件夹下的webapps目录,启动tomcat,tomcat会自动解压项目4 完成后在浏览器中放问 localhost:8080/项目名称 出现项目页面则成功 三. 域名解析在腾讯云的域名管理界面解析域名 四. 绑定域名如果有一个服务器已经部署好项目已做域名解析使用IP:8080/项目名称 能够访问项目 一般你这样做就能使用域名直接访问项目了: cd 到你的tomcat下修改server.xml文件中监听端口:修改前:1&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 修改后:1&lt;Connector port=\"80\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 也就是说将监听端口，修改为默认的80端口。 继续修改server.xml中Host找到1&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; 修改为：1&lt;Host name=\"你的域名\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; 以及在该…标签内添加标签1&lt;Context path=\"\" docBase=\"/myApp\" /&gt; docBase属性填写你的项目位置，最好是绝对路径即…../webapps/myApp。 whatoeat项目中,tomcat xml文件最终修改如下: 123456&lt;Host name=\"www.whatoeat.cn\" appBase=\"C:\\virtualhost\\dengtianyue\" unpackWARs=\"true\"autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\"&gt;&lt;Context path=\"/whaToEat\" docBase=\"C:\\virtualhost\\dengtianyue\\whaToEat\" reloadable=\"false\" source=\"org.eclipse.jst.jee.server:whaToEat\"/&gt; &lt;/Host&gt;&lt;/Engine&gt; &lt;Connector port=\"80\" redirectPort=\"8443\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\"/&gt;&lt;/Service&gt; 重启tomcat,打开浏览器,输入域名访问即可","tags":[]},{"title":"基于吃什么项目对MVC分层模型的学习","date":"2017-04-24T12:35:02.000Z","path":"2017/04/24/基于吃什么项目对MVC分层模型的学习/","text":"在做完”Whatoeat”这个项目后,对于MVC分层模型有了更深层次的了解 MVC分层模型: Whatoeat 的目录结构: 目录结构解析:src: action : 动作层,起控制器的作用—–取掉转 db : 数据库层.负责连接数据库,获得sessionFactory entity : 实体层,对应数据库表的实体类 service : 业务逻辑接口层 serviceimpl : 接口实现层 对数据进行一些操作 Test单元测试类,负责模块的测试 WebrootWeb应用部署后各文件的所在地,包括Web前端的css,js等和jsp文件.java文件编译后将保存于WEB-INF/class目录下","tags":[]},{"title":"新手使用github的心得","date":"2017-03-31T12:33:20.000Z","path":"2017/03/31/新手使用github的心得/","text":"作为一个新手最近开始使用github,记录一下自己初识github的心得 #1. 建立仓库建立仓库的过程不多说,登录到github网站以后,点击绿色的 New repository,然后按照步骤创建项目就可以了.创建的过程中可以选择是否自动生成readme文件. #2. 克隆仓库到本地 可以克隆的前提是已经配置好git和ssh,关于git和ssh的配置可以在网上搜索,有很多的大神分享=.= git配置好以后,在本地新建一个文件夹,在文件夹中鼠标右键,选择git bash,进入命令行后执行1git clone https://github.com/dengtianyue/whatToEat.git 这个网址就是你刚刚建立仓库以后,浏览器中显示的网址后添加”.git”就可以了,也可以进入仓库后,右侧有一个绿色的 Clone or download按钮,点击它也会出来这个url. 克隆成功后,会发现文件夹里已经多出了一个以仓库名为名字的文件夹.#3. 对文件夹进行git初始化12git initgit remote https://github.com/dengtianyue/whatToEat.git 初始化只要执行一次就够了,以后不需要再次执行.如果执行初始化过程中它提示 fatal: remote origin already exists说明已经配置过了,可以直接进行下一步 #4. push文件123git add . git commit -m '备注,一定要写' git push origin master 其中add 后可以加文件名 ,加一个.是指全部上传 如果执行 git push origin master 时报错:error:failed to push som refs to…则可以试着执行1git pull origin master 再执行1git push origin master 先把远程服务器github上面的文件拉先来，再push 上去。ps:这是一个新手初步使用github的心得,十分浅显.深入了解github的使用请参考网上大神们的教程=.=","tags":[]},{"title":"多对多关系的处理办法","date":"2017-03-31T11:36:05.000Z","path":"2017/03/31/多对多关系的处理办法/","text":"多对多关系的处理在数据库设计的过程中,经常会遇到两张表是多对多的关系.如订单和商品之间的关系:一个订单包含了很多商品,而一种商品同时也可能属于多个订单.这时就需要通过建立一个第三方关联表,将多对多关系拆分成两个一对多关系.其中关联表为多方. 实例如下:背景 一种菜品属于一个菜系,一个菜系也包括很多菜品; 一种菜品根据原材料分可以分为多个种类,如番茄炒蛋可以归为蛋类也可归为蔬菜类,而每个种类下也有多个菜品 通过建立菜系-菜品关联表,种类-菜品关联表来处理菜品与菜系,菜品与种类之间的多对多关系 数据表名词解释: food:菜品 foodstyle:菜系 foodtype:种类 stylelink:菜系-菜品关联表 typelink:种类-菜品关联表 对应的ER图如下:","tags":[]},{"title":"Hibernate中配置映射关系","date":"2017-03-31T11:06:43.000Z","path":"2017/03/31/Hibernate中配置映射关系/","text":"Hibernate中配置映射关系准备工作 进行Hibernate的基本配置 创建HibernateUtil工具类 进行数据表的建立 创建持久化类和映射关系文件 配置单向一对多关系使用标签在一方的hbm.xml文件中,配置单向的一对多映射,如:123456789&lt;!-- 配置单向的一对多映射 设置inverse属性为true 由多方维护关联关系 , 设置cascade=\"save-update\",当进行保存和更新时级联操作所关联的对象--&gt; &lt;set name=\"students\" table=\"student\" inverse=\"false\" lazy=\"true\" cascade=\"save-update\"&gt; &lt;!-- 指定关联的外键列 --&gt; &lt;key&gt; &lt;column name=\"gid\" /&gt; &lt;/key&gt; &lt;one-to-many class=\"entity.Student\" /&gt; &lt;/set&gt; 测试类:1234567891011121314151617181920212223242526272829//将学生添加到班级public static void add()&#123; Grade g = new Grade(\"JAVA1\",\"JAVA软件开发一班\"); Student stu1 = new Student(\"张三\",\"男\"); Student stu2 = new Student(\"青青\",\"男\"); //如果希望在学生表中添加对应的班级编号,需要在班级中添加学生,建立关联关系 g.getStudents().add(stu1); g.getStudents().add(stu2); Session session = HibernateUtil.getSession(); Transaction tx = session.beginTransaction(); session.save(g); session.save(stu1); session.save(stu2); tx.commit(); HibernateUtil.closeSession(session);&#125;//查询班级学生信息public static void findStudentsByGrade()&#123; Session session = HibernateUtil.getSession(); Grade grade = (Grade) session.get(Grade.class, 1); System.out.println(grade.getGname()+\",\"+grade.getGdesc()); Set&lt;Student&gt;students = grade.getStudents(); for(Student stu : students)&#123; System.out.println(stu.getSname()+\",\"+stu.getSex()); &#125;&#125; 单向多对一的配置在多方的hbm.xml文件中,使用标签配置如:12&lt;!-- 配置多对一关联配置 --&gt; &lt;many-to-one name=\"grade\" class = \"entity.Grade\" column=\"gid\"&gt;&lt;/many-to-one&gt; 当双方关系都配置好后,即双向映射已经配置测试:1234567891011121314151617181920212223242526272829303132//保存,测试多对一映射public static void save()&#123; Grade g = new Grade(\"JAVA1\",\"JAVA软件开发一班\"); Student stu1 = new Student(\"呵呵\",\"男\"); Student stu2 = new Student(\"小美\",\"女\"); //设置关联关系 g.getStudents().add(stu1); g.getStudents().add(stu2); stu1.setGrade(g); stu2.setGrade(g); Session session = HibernateUtil.getSession(); Transaction tx = session.beginTransaction(); session.save(g); //session.save(stu1); //session.save(stu2); tx.commit(); HibernateUtil.closeSession(session);&#125; //双向多对一测试public static void findGradeByStudent()&#123; Session session = HibernateUtil.getSession(); Student stu = (Student) session.get(Student.class, 2); Grade grade = stu.getGrade(); System.out.println(stu.getSid()+\",\"+stu.getSname()+\",\"+stu.getSex()); System.out.println(grade.getGid()+\",\"+grade.getGname()+\",\"+grade.getGdesc()); HibernateUtil.closeSession(session);&#125; 相关知识点:1.inverse属性的用法在一对多关联关系中默认有one方维护关联关系，因为是双向一对多关联关系，所以one方需进行两次关联关系的维护，当在one方设置inverse属性值为true时，反转，即让多方进行关联关系的维护，此时不需要执行update 多方表名（student） set 单方表的主键（多方表中的外键即gid）等于单方某记录的gid值当sid为值一，sid为值二，，，，（student表中有n个记录则需执行n次操作）这些操作，所以当在one方设置inverse属性值为true时有利于改善系统性能。 2.cascade属性的用法 当设置cascade属性部位none时,Hibernate会自动持久化所关联的对象 cascade属性的常用设置: all—&gt;对所有操作进行级联操作 save-update–&gt;执行保存和更新操作时进行级联操作 delete–&gt;执行删除操作时进行级联操作 none–&gt;对所有操作不进行级联操作","tags":[]},{"title":"Hibernate的基本用法","date":"2017-03-29T16:28:42.000Z","path":"2017/03/30/Hibernate的基本用法/","text":"Hibernate 的基本开发步骤1.编写配置文档hibernat.cfg.xml例如:1234567891011121314151617181920&lt;session-factory&gt; &lt;!--数据库用户名--&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;!--数据库登录密码--&gt; &lt;property name=\"connection.password\"&gt;123456&lt;/property&gt; &lt;!--jdbc驱动 --&gt; &lt;property name=\"connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--设置端口 字符集等 --&gt; &lt;property name=\"connection.url\"&gt;jdbc:mysql://127.0.0.1:3306/hibernate?useUnicode=true&amp;characterEncoding=utf-8&lt;/property&gt; &lt;!--方言 --&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!--是否直接打印出sql语句 --&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!--sql格式 --&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;!--ddl生成策略--&gt; &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!--对应的映射 --&gt; &lt;mapping resource=\"Students.hbm.xml\"/&gt; &lt;/session-factory&gt; 单一主键:1.assigned 由java应用程序负责生成（手工赋值） 2.native 由底层数据库自动生成标示符，如果是MySQL就是increment，如果是Oracle就是sequence，等等 Ps1：assigned注意：如果实体类中设置的主键id是基本类型int的话，则可以不用赋值，系统默认值为0；如是引用类型Integer话，则默认值为null，不赋值系统则报错。 Ps2：native注意：系统会自动选择该数据库对应的自动增值方式，从1开始。即使手动给他赋值，也不会起作用，但也不会报错。 2.编写实体类需要符合JAVA BEAN 规范 即:1、公有的类。2、提供公有的不带参数的默认的构造方法。3、属性私有。4、属性setter/getter封装 3.生成对应实体类的映射文件可在包上鼠标右键,点击new-&gt;other-&gt;Hibernate-&gt;Hibernate XML Mapping file(hbm.xml)自动创建如:1234567891011121314151617181920212223242526&lt;hibernate-mapping&gt; &lt;class name=\"Students\" table=\"STUDENTS\"&gt; &lt;id name=\"id\" type=\"int\"&gt; &lt;column name=\"ID\" /&gt; &lt;!--主键策略--&gt; &lt;generator class=\"assigned\" /&gt; &lt;/id&gt; &lt;property name=\"sname\" type=\"java.lang.String\"&gt; &lt;column name=\"SNAME\" /&gt; &lt;/property&gt; ...................... &lt;!-- &lt;property name=\"address\" type=\"java.lang.String\"&gt; &lt;column name=\"ADDRESS\" /&gt; &lt;/property&gt; --&gt; &lt;property name=\"picture\" type=\"java.sql.Blob\"&gt; &lt;column name=\"PICTURE\" /&gt; &lt;/property&gt; &lt;component name=\"address\" class=\"Address\"&gt; &lt;property name=\"postcode\" column=\"POSTCODE\"/&gt; &lt;property name=\"phone\" column=\"PHONE\"/&gt; &lt;property name=\"address\" column=\"ADDRESS\"/&gt; &lt;/component&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 常用配置如下:4.调用Hibernate API进行测试例如:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.sql.Blob;import java.util.Date;import org.hibernate.Hibernate;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;import org.hibernate.service.ServiceRegistryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;//测试类public class StudentsTest &#123; private SessionFactory sessionFactory; private Session session; private Transaction transaction; @Before public void init()&#123; //创建配置对象 Configuration config = new Configuration().configure(); //创建服务注册对象 ServiceRegistry serviceRegistry = new ServiceRegistryBuilder().applySettings(config.getProperties()).buildServiceRegistry(); //创建会话工厂对象 sessionFactory = config.buildSessionFactory(serviceRegistry); //会话对象 session = sessionFactory.openSession(); //开启事务 transaction = session.beginTransaction(); &#125; @After public void distory()&#123; //提交事务 transaction.commit(); session.close(); sessionFactory.close(); &#125; @Test public void testSaveStudents()&#123; //生成学生对象 Students s = new Students(1,\"小明\",\"男\",new Date()); Address address = new Address(\"312312\",\"09876666\",\"杭州\"); s.setAddress(address); session.save(s);//保存对象进入数据库 &#125; @Test public void testWriteBlob()throws Exception&#123; Students s = new Students(4,\"小明\",\"男\",new Date()); //获得照片文件 File f = new File(\"f:\"+File.separator+\"头像.jpg\"); //获得输入流 InputStream input = new FileInputStream(f); //创建一个Blob对象 Blob image = Hibernate.getLobCreator(session).createBlob(input, input.available()); //设置照片属性 s.setPicture(image); //保存学生 session.save(s); &#125; @Test public void testReadBlob()throws Exception &#123; Students s = (Students) session.get(Students.class, 4); //获得blob对象 Blob image =s.getPicture(); //创建输入流 InputStream input = image.getBinaryStream(); //创建输出流 File f = new File(\"f:\"+File.separator+\"头像2.jpg\"); OutputStream output = new FileOutputStream(f); //缓冲区 byte[] buff = new byte[input.available()]; input.read(buff); output.write(buff); input.close(); output.close(); &#125; Hibernate其他一些基础知识transaction：事务Hibernate对数据的操作都是封装在事务当中，并且默认是非自动提交的方式。所以用session保存对象时，如果不开启事务，并且手工提交事务，对象并不会真正保存在数据库中 如上例中的： 1234 //开启事务transaction = session.beginTransaction(); //提交事务transaction.commit(); session1.getCurrentSession在事务提交或者回滚之后会自动关闭，而openSesssion需要你手动关闭。如果使用openSession而没有手动关闭，多次之后会导致连接池溢出！2.openSession每次创建新的session对象，getCurrentSession使用现有的session对象（现有session没commit之前） 基本类型 对象类型","tags":[]},{"title":"Hello World","date":"2017-03-29T03:19:08.088Z","path":"2017/03/29/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]